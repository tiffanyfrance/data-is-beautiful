<!DOCTYPE html>
<meta charset="utf-8">
<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
<style>
  * {
    font-family: 'Open Sans', sans-serif;
  }
  #tooltip {
    position: absolute;
    background: #fff;
    padding: 2px 10px;
    border-radius: 3px;
    font-size: 10px;
    color: #333;
  }
</style>
<body style="background: #333;">
  <div style="text-align: center;">
    <svg width="960" height="1260" font-family="sans-serif" font-size="10" style="margin: 0 auto;"></svg>
  </div> 

  <div id="tooltip" style="opacity: 0;">
    <p>Name: <span id="name">Captain Awesome</span></p>
    <p>Group: <span id="group">0</span></p>
    <p>Number of Hours: <span id="hours">100</span></p>
  </div>

<script src="https://d3js.org/d3.v4.min.js"></script>
<!-- <script src="d3-scale-radial.js"></script> -->
<script>

let svg = d3.select("svg"),
    width = +svg.attr("width"),
    height = +svg.attr("height")
    baseRadius = 300;

let colors = d3.schemeCategory20;

let base = svg.append('g')
    .attr('class','base-group')
    .attr('transform',`translate(${(width / 2)}, ${(height / 2)})`);

let tooltip = d3.select("#tooltip");

d3.csv("nasa.csv", function(d, i, columns) {
  return {
    hours: +d['Cumulative hours of space flight time'],
    group: (+d[' Group'] - 1),
    name: d['Astronaut'],
  }
}, function(error, data) {
  console.log(data);

  /* theta is the letter for angle in math */
  let theta = (2 * Math.PI) / data.length;
  let startAngle = -1 * Math.PI / 2;

  for(let i = 0; i < data.length; i++) {
    let d = data[i];
    let count = Math.ceil(d.hours / 100);
    let newData = [];
    let angle = startAngle + (i * theta);

    if(count === 0) {
      newData.push({
        angle,
        radius: baseRadius,
        ...d
      });
    } else {
      for(let j = 0; j < count; j++) {
        newData.push({
          angle,
          radius: baseRadius + (j * 6),
          ...d
        });
      }
    }

    d.newData = newData;
  }

  base.append('circle')
    .attr("fill", "none")
    .attr("stroke", "none")
    .attr("r", baseRadius);

  let dataCircles = base.append('g')
    .attr('class', 'data-circles');

  let astronaut = dataCircles.selectAll('g')
    .data(data)
    .enter()
    .append('g');

  astronaut
    .selectAll('circle')
    .data((d) => {
      return d.newData;
    })
    .enter()
    .append('circle')
    /* cosine * radius of base circle  */
    .attr('cx', (d, i) => {
      return Math.cos(d.angle) * d.radius;
    })
    /* sine * radius of base circle  */
    .attr('cy', (d, i) => {
      return Math.sin(d.angle) * d.radius;
    })
    .attr('r', 3)
    .attr('fill', (d) => (d.hours > 0) ? colors[d.group] : '#333')
    .attr('stroke', (d) => colors[d.group])
    .attr('stroke-width', 1)
    .on('mouseover', function(d) {
      tooltip
        .style("left", (d3.event.pageX + 10) + "px")
        .style("top", (d3.event.pageY + 10) + "px");

      tooltip
        .select("#group")
        .text(d.group + 1);

      tooltip
        .select("#hours")
        .text(d.hours);
        
      tooltip.select("#name")
        .text(d.name);

      tooltip
        .transition()
        .duration(500)
        .style('opacity', 1);
    })
    .on("mouseout", function(d) {
      tooltip
        .transition()
        .duration(500)
        .style('opacity', 0);
    })

});



// let innerRadius = 180,
//     outerRadius = Math.min(width, height) / 2,
//     g = svg.append("g").attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

// var x = d3.scaleBand()
//     .range([0, 2 * Math.PI])
//     .align(0);

// var y = d3.scaleRadial()
//     .range([innerRadius, outerRadius]);

// var z = d3.scaleOrdinal()
//     .range(["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00"]);

// d3.csv("data.csv", function(d, i, columns) {
//   for (i = 1, t = 0; i < columns.length; ++i) t += d[columns[i]] = +d[columns[i]];
//   d.total = t;
//   return d;
// }, function(error, data) {
//   if (error) throw error;

//   x.domain(data.map(function(d) { return d.State; }));
//   y.domain([0, d3.max(data, function(d) { return d.total; })]);
//   z.domain(data.columns.slice(1));

//   g.append("g")
//     .selectAll("g")
//     .data(d3.stack().keys(data.columns.slice(1))(data))
//     .enter().append("g")
//       .attr("fill", function(d) { return z(d.key); })
//     .selectAll("path")
//     .data(function(d) { return d; })
//     .enter().append("path")
//       .attr("d", d3.arc()
//           .innerRadius(function(d) { return y(d[0]); })
//           .outerRadius(function(d) { return y(d[1]); })
//           .startAngle(function(d) { return x(d.data.State); })
//           .endAngle(function(d) { return x(d.data.State) + x.bandwidth(); })
//           .padAngle(0.01)
//           .padRadius(innerRadius));

//   var label = g.append("g")
//     .selectAll("g")
//     .data(data)
//     .enter().append("g")
//       .attr("text-anchor", "middle")
//       .attr("transform", function(d) { return "rotate(" + ((x(d.State) + x.bandwidth() / 2) * 180 / Math.PI - 90) + ")translate(" + innerRadius + ",0)"; });

//   label.append("line")
//       .attr("x2", -5)
//       .attr("stroke", "#000");

//   label.append("text")
//       .attr("transform", function(d) { return (x(d.State) + x.bandwidth() / 2 + Math.PI / 2) % (2 * Math.PI) < Math.PI ? "rotate(90)translate(0,16)" : "rotate(-90)translate(0,-9)"; })
//       .text(function(d) { return d.State; });

//   var yAxis = g.append("g")
//       .attr("text-anchor", "middle");

//   var yTick = yAxis
//     .selectAll("g")
//     .data(y.ticks(5).slice(1))
//     .enter().append("g");

//   yTick.append("circle")
//       .attr("fill", "none")
//       .attr("stroke", "#000")
//       .attr("r", y);

//   yTick.append("text")
//       .attr("y", function(d) { return -y(d); })
//       .attr("dy", "0.35em")
//       .attr("fill", "none")
//       .attr("stroke", "#fff")
//       .attr("stroke-width", 5)
//       .text(y.tickFormat(5, "s"));

//   yTick.append("text")
//       .attr("y", function(d) { return -y(d); })
//       .attr("dy", "0.35em")
//       .text(y.tickFormat(5, "s"));

//   yAxis.append("text")
//       .attr("y", function(d) { return -y(y.ticks(5).pop()); })
//       .attr("dy", "-1em")
//       .text("Population");

//   var legend = g.append("g")
//     .selectAll("g")
//     .data(data.columns.slice(1).reverse())
//     .enter().append("g")
//       .attr("transform", function(d, i) { return "translate(-40," + (i - (data.columns.length - 1) / 2) * 20 + ")"; });

//   legend.append("rect")
//       .attr("width", 18)
//       .attr("height", 18)
//       .attr("fill", z);

//   legend.append("text")
//       .attr("x", 24)
//       .attr("y", 9)
//       .attr("dy", "0.35em")
//       .text(function(d) { return d; });
// });

</script>
</body>